# 변수

## 관련 파일
```
Test12_1.java ~ Test12_9.java
```

## 메모리 준비_이론 정리

```
- 메모리 준비(변수 선언)
  · 메모리 준비 시 어떤 종류의 값을 저장할 것인지에 대한 지정 필요
  · 해당 용도로만 사용 가능
  · 값의 종류 : 데이터 타입
  · 문법
    => [값 종류] 메모리 이름;
       [데이터 타임] 변수명;

- 메모리와 데이터 타입
  1) 정적 타입 바인딩(static type binding)
  · 메모리를 특정 용도로 묶어 놓는 것
  · 메모리 준비 시 해당 메모리에 담을 값을 종류를 한 번 결정하면 다시 변경 불가
  · Java, C/C++ 등 복잡한 언어에서 사용
  · 메모리를 한 가지 용도로 제한하는 이유?
    => 유지보수 시 혼동을 줄이기 위해
    => 시스템 안정성 제고를 위한 변수의 잘못된 사용 방지

  2) 동적 타입 바인딩(dynamic type binding)
  · 메모리가 특정 용도에 묶이지 않는 것
  · 메모리에 값을 넣을 때 해당 메모리의 용도 결정
  · 다른 종류의 값을 넣으면 해당 메모리의 용도 변경
  · JavaScript, Python 등 스크립트 류의 프로그래밍 언어에서 사용

- 자바에서 제공하는 메모리 종류[데이터 타입]
  1) 정수 값
  · byte : 1바이트 메모리 : -128 ~ +127
  · int : 2바이트 메모리 : -32768 ~ +32767
  · short : 4바이트 메모리 : 약 -21억 ~ +21억
  · long : 8바이트 메모리 : 약 -900경 ~ +900경
  ※ Java의 정수 값 표현은 두 가지 크기만 가능 : 4byte, 8byte(1byte, 2byte 불가.
    연산이 4byte default이므로)

  2) 부동소수점 값
  · float : 4바이트 메모리. 유효자릿 수 7자리
  · double : 8바이트 메모리. 유효자릿수 15자리
  
  3) 논리 값
  · boolean   : 4바이트 메모리. 배열일 때는 1바이트를 사용

  4) 주소 값
  배열이나 인스턴스의 주소를 담는 경우에 사용

- 자바 원시 데이터 타입(primitive data type)
  · JAVA의 기본 정의 데이터 타입
  · 종류 : byte, short, int, long, float, double, boolean, char
  · 이 외의 데이터는 개발자가 직접 정의해서 사용해야 함(객체)
  · 사용자(개발자) 정의 데이터 타입 : 개발자가 추가 정의한 데이터 타입
  · 문법 : class 문법 사용

- class의 목적
  · 사용자 정의 데이터 타입을 만드는 문법
  · 메서드를 관리하기 쉽게 분류하는 문법 
  즉, 사용자 정의 데이터를 만들고 메소드를 쉽게 분류하기 위해 존재.
  객체 지향 언어 개발의 목적
```

## 메모리 준비_실습

```
- 값을 저장하기 위해 메모리를 준비하는 방법을 알아보자!

- Step1. 자바 원시 타입의 메모리 준비

  · byte b; => 정수 저장용 1바이트 크기 메모리 준비
  · short s; => 정수 저장용 2바이트 크기 메모리 준비
  · int i; => 정수 저장용 4바이트 크기 메모리 준비(default 값)
  · long l; => 정수 저장용 8바이트 크기 메모리 준비(숫자 뒤에 L 또는 l 붙여야 함)
  · float f; => 부동소수점 저장용 4바이트 크기 메모리 준비
  · double d; => 부동소수점 저장용 8바이트 크기 메모리 준비
  · boolean bool; => 논리 값 저장용 4바이트 크기 메모리 준비
  · char c; => 유니코드 값 저장용 2바이트 크기 메모리 준비

- Step2. 메모리에 값 저장
  · '=' 연산자(assignment) 활용
  · 메모리 값 저장 형식 => l-value = r-value
  · l-value는 항상 메모리여야 함
  · r-value는 값 또는 메모리가 될 수 있음

  ex.
    b = 100;
    s = 100;
    i = 100;
    l = 100;
    f = 3.14f;
    d = 3.14;
    bool = true;
    c = 44032;  

- Step3. 메모리 저장 값 출력

    System.out.println(b);
    => 100
    System.out.println(s);
    => 100
    System.out.println(i);
    => 100
    System.out.println(l);
    => 100
    System.out.println(f);
    => 3.14
    System.out.println(d);
    => 3.14
    System.out.println(bool);
    => true
    System.out.println(c);
    => 가
```

### 메모리 값 저장 상세

```
- 메모리 준비
        int i;
        int j;

- 메모리에 값 저장
  · '=' 연산자 사용 
  · '=' 연산자 왼편 : 'l-value'. 반드시 메모리여야 함
  · '=' 연산자 오른편 : 'r-value'. 메모리나 값이 될 수 있음 
  · r-value가 값인 경우 => i = 100; 
  · r-value가 변수인 경우 => j = i;
    System.out.println(i); => 100
    System.out.println(j); => 100
  · 컴파일 오류의 예 : 100 = 200;
  · 메모리 준비 시 선언한 종류가 아닌 다른 종류으 값 저장 불가
    컴파일 오류 => i = 3.14;
  · 메모리를 준비하지 않고 사용 가능
    "cannot find symbol" 컴파일 오류 발생! => x = 100;
```

### 변수 초기화 문장

```
- 변수를 선언하고 값을 저장하는 다양한 방법

- 콤마 사용
  int i, j;
  i = 100;
  j = 200;

- 변수 선언 시 초기 값 바로 저장
  int k = 100;

- 콤마 사용하여 여러 개의 변수 선언과 동시에 초기 값 저장
  int x = 100, y, z = 300;

- 주의 사항
  · 변수 선언 후 초기화 미 수행 시 해당 변수 사용 불가
  · 위 케이스의 y가 그런 경우
    System.out.printLn(y); => 컴파일 오류 발생
```

### 상수

```
- 상수의 사용법

- 변수 : 언제든 값 변경 가능. 글나 최종 값이 해당 변수에 저장
  int i;
  i = 100;
  i = 200;

- 상수 선언
  · 한 번 값 저장 시 변경 불가
  · modifier : final
  · 사용 예 : final int j;
        
- 상수의 용도
  · 값 변경을 원하지 않는 변수
  · 개발 중 실수로 인한 값을 변경 방지
  · 값의 변경으로 인한 컴파일러 오류 메세지 확인을 위해
```

### 자바의 최소 연상 단위

```
- 4바이트 정수 리터럴(literal) : 메모리 저장 가능 범위 이내만 사용 가능
  · 사용 예 : b3 = 100;

- 리터럴과 리털럴의 연산 결과도 리터럴로 간주
  · 사용 예 : b3 = 50 + 50;
        
- 변수의 연산 결과는 사용 불가

  · 변수의 값은 언제든지 변경 가능함을 가정하므로
    컴파일러가 변수의 값이 메모리 저장 가능 범위 이내라 가정 불가
  · 자바의 최소 연산 단위 : 4바이트 int
    -> byte나 short 메모리 값 연산 시 4바이트 int형 임시 메모리 만들어 해당 값 저장 수 연산 수행.
    => 연산 결과 또한 4바이트
    => 컴파일 오류 :
        byte b1 = 50;
        byte b2 = 50;
        byte b3;
        b3 = b1 + b2;
        
- 리터럴과 변수의 연산 결과도 int로 간주
  => 컴파일 오류 : b3 = b1 + 50;

- 자바 프로그래밍 시 작은 정수라도 int 사용 권장
  => byte 메모리는 바이너리 데이터 다룰 시만 사용

  ※ 바이너리(binary) 파일
    - 특정 파일 형식으로 데이터가 저장된 파일
    - 파일 읽고 쓰기 위한 전용 프로그램 필요
    - 메모장 등 일반 텍스트 편집기로 편집 불가
      => .gif, .jpeg, mp3, .hwp, .doc, .xls, .ppt, .exe, .class 등

  ※ 텍스트(text) 파일
    - ASCII, ISO-8859-1, EUC-KR, MS949, Unicode, UTF-8 등 특정 charset 규칙에
      따라 데이터가 저장된 파일
    - 일반 텍스트 편집기로 파일을 읽고 쓸 수 있음
   - 메모장 등 일반 텍스트 편집기로 편집 가능
     => .html, .js, .css, .rtf, .xml, .properties, .java, .c, .cpp, .bat, .sh,
        .gradle, .project 등
```

### 부동 소수점 변수

```
- 부동소수점을 변수에 저장하는 방법을 알아보자!

- 부동소수점 저장 메모리 준비
  · 단정도(7자리) 부동소수점 저장 메모리
        float f1;
        f1 = 9876567f;
        System.out.println(f1);
        => 9876567.0

  · 정수와 달리 부동소수점 변수는 메모리에 저장할 수 있는 크기 보다 더 큰 수를
    저장해도 컴파일 오류 미발생하나 값이 잘림
    ex. 8바이트 정수를 4바이트 메모리에 저장
        f1 = 9876543456789L;  
        System.out.println(f1); 
        => 9.8765436E12 = 9876543600000

  · 8바이트 부동소수점을 4바이트에 저장 시, 컴파일 오류 발생
        f1 = 9876543.4567;

  · 8바이트 부동소수점을 4바이트에 넣기 위해 리터럴 뒤에 f를 붙이면?
        f1 = 9876543.4567f;
        // f1이라는 변수에 값을 넣기 전에 이미 9876543.4567 값이 4바이트 부동소수점으로 변환되면서 값이 잘려 출력 시 잘린 값이 출력
        System.out.println(f1);
        => 9876543.0

- 정수 값은 부동소수점 메모리에 저장하지 말 것.
  부동소수점 자체가 근사값 표현 방식이므로 정확한 값 다룰 수 없음
- int는 double 메모리 저장 시 원래 값의 보존률이 높으나, long(64bit)는
  double 자체가 수를 저장하는 공간이 53bit이므로 거진 잘리게 됨
```

### 논리 값 저장 변수 

```
- 논리 값을 저장할 변수를 만들고 사용하는 방법을 알아보자!

- 논리 값 저장할 메모리 준비
  · boolean b1;

  · 저장할 수 있는 값은 자바 언어에 미리 정의된 true, false만 가능
    ex. b1 = true;
        System.out.println(b1);

        b1 = false;
        System.out.println(b1);

- JVM에서 내부적으로 true, false 다룰 시 1, 0으로 다루지만, 개발자가 메모리에
  1 또는 0 입력은 불가
  ex. 컴파일 오류 예
      b1 = 1;
      b1 = 0;

- boolean 타입은 +, -, *, / 등의 연산자가 정의되어 있지 않아 사용 불가
  ex. 컴파일 오류 예 : b1 = true - false;   
```

### 문자 코드 값 저장 변수 

```
- 문자를 메모리에 저장하는 방법을 알아보자!

- 문자 저장 변수 준비
  · 자바는 유니코드를 사용하여 문자를 표현므로 유니코드를 저장할 
    2바이트 메모리가 필요
  · 문자 코드이므로 0 ~ 65535까지의 수를 저장 가능
    즉, -값이 없음
  · char => unicode CS의 code 값 저장
    굉장히 중요함. 문자를 저장하는 것이 아니다.

    char c1;

  · 문자 저장을 위해 해당 문자의 유니코드 값을 저장하면 됨
    유니코드의 10진수 표현 => c1 = 44032;
    유니코드의 16진수 표현 => char c2 = 0xAC00;
    System.out.println(c1);
    => 가
    System.out.println(c2);
    => 가

  · 본인 이름 저장
    char n1 = 0xBC15;
    char n2 = 0XC815;
    char n3 = 0xB0A8;
    System.out.printf("%c %c %c\n", n1, n2, n3);
    => 박 정 남

  · 문자를 메모리 저장 시점마다 해당 문자의 유니코드를 확인하기 어려우므로
    자바는 연산자를 제공하여 문자로 해당 글자의 유니코드 값 리턴
    n1 = '빅';
    n2 = '정'; 
    n3 = '남';
    System.out.printf("%c %c %c\n", n1, n2, n3);
    ※ 작은 따옴표는 해당 글자의 유니코드 값을 리턴한다.

  · 문자 '7'을 숫자 7로 바꿔라!
    char x = '7';
    int num;
    num = x - '0'; 
    => 0055(DEC) - 0048(DEC) = 7
    System.out.println(num);
    => 7
```