# 자바에서 값 표현(literal)하기 - 메모리에 정수 저장

## 관련 파일

```
Test11_7.java
```

## 자바의 정수 저장_2의 보수 방식

```

1) 자바는 정수를 2의 보수 방식으로 메모리에 저장

2) 양의 정수 값 저장

- 양의 정수 100을 메모리에 저장

  => 100 = 0000 0000 0000 0000 0000 0000 0110 0100

     System.out.println(100);
     System.out.println(Integer.toBinaryString(100));

3) 음의 정수 값 저장

- 음의 정수 -100을 메모리에 저장

  => -100 = 1111 1111 1111 1111 1111 1111 1001 1100

     System.out.println(-100);
     System.out.println(Integer.toBinaryString(-100));
```

## 정수의 2진수 표현법_부호-크기/절대값(Sign-Magnitude)

```
- 가장 좌측 1비트를 부호 비트로 사용
  양수 : 0 / 음수 : 1

- 나머지 비트는 절대값(magnitude)

  ex. +24와 -24의 8비트 표현
  · +24 : 0001 1000
  · -24 : 1110 0111

- 표현 가능 범위(8비트 기준) : -127 ~ +127
  0111 1111 => 127
  0111 1110 => 126
  0111 1101 => 125
  0111 1100 => 124
        .
        .
        .
  0000 0001 => 1
  0000 0000 => +0
  1000 0000 => -0
  1000 0001 => -1
        .
        .
        .
  1111 1100 => -124
  1111 1101 => -125
  1111 1110 => -126
  1111 1111 => -127

- 문제점 
  · 0이 두 개 : +0, -0
  · 양수 음수 합산 불가
  
  => 4비트 1 + -1 = ?
     0001(+1) + 1001(-1) = 1010 (-2) 
     => 음수와 양수를 더하는 컴퓨팅 회로 별도 설계 필요

- 장점 : 이해가 쉬움

- 용도 : 부동 소수점 가수부(significand or mantissa) 표현 시
```

## 1의 보수(Ones' Complement)

```
- 모든 비트를 반대 값으로 변경

  ex. +24와 -24의 8비트 표현
  · +24 : 0001 1000
  · -24 : 1110 0111

- 수의 범위(8비트 기준): -127 ~ +127
  0111 1111 (127)
  0111 1110 (126)
  0111 1101 (125)
     ...
  0000 0001 (1)
  0000 0000 (+0)
  1111 1111 (-0)
  1111 1110 (-1)
     ...
  1000 0010 (-125)
  1000 0001 (-126)
  1000 0000 (-127)

- 문제점
  · 0이 두 개 : +0 / -0
  · 합산 후 1을 더해야 함
  
  => 4비트 1 + -1 = ?
     0001(+1)
     1110(-1)
     --------
     1111 (-0)

     0101(+5)
     1100(-3)
     --------
     0001 (1)
    +0001 (1)    -> 1 추가
     --------
     0010 (2)
```
## 2의 보수(Twos' Complement)

```
- 모든 비트를 반대 값으로 변경 후 1 합산

- 장점
  · 1의 보수의 문제점 해결
    a. -0 없앰 -> -128까지 표현 가능
  · 음수의 합산 가능

- 8비트에서 2의 보수 만들기_1
  
  -41 표현

  DEC 41 -> Binary 0010 1001

  ->  1101 0110
  -> +0000 0001 
  ->  1101 0111

- 8비트에서 2의 보수 만들기_2
  
  오른쪽에서 1을 찾는다.
  그 왼편에 이는 모든 비트를 반대 값으로 바꾼다.

  ex. 0010 1001(41) => 1101 0111(-41)
      
      0010 1100(44) => 1101 0100(-44)

- 8비트에서 2의 보수 만들기_3

  2^n(8비트일 경우, 2^8 = 256)에서 음수 값 만큼 뺀다.

  ex. -41 => 256 - 41 = 215 = 1101 0111
      -44 => 256 - 44 = 212 = 1101 0100

- 수의 범위(8비트 기준) : -128 ~ +127\

  0111 1111 (127)
  0111 1110 (126)
  0111 1101 (125)
     ...
  0000 0010 (2)
  0000 0001 (1)
  0000 0000 (+0)
  1111 1111 (-1)
  1111 1110 (-2)
     ...
  1000 0011 (-125)
  1000 0010 (-126)
  1000 0001 (-127)
  1000 0000 (-128)
```

## K-초과(Excess-K)

```
- 오프셋 바이너리(offset binary) 또는 바이어스된 표기법(biased representation)

- K를 바이어스 값이라 부르며, 표현하려는 값에 더할 때 사용
  ex. 표현하려는 값 + 초과 값(K) = 결과

- 바이어스 값(K)을 구하는 공식:

  K = 2^(비트수 - 1)

  ex. 8비트일 경우 ---> K = 2^(8 - 1) = 2^7 = 128, 결과 = 128 + 값
      1111 1111 = 128 + 127
      1111 1110 = 128 + 126
      1111 1101 = 128 + 125
               ...
      1000 0001 = 128 + 1
      1000 0000 = 128 + 0
      0111 1111 = 128 + (-1)
               ...
      0000 0010 = 128 + (-126)
      0000 0001 = 128 + (-127)
      0000 0000 = 128 + (-128)

- IEEE 부동소수점 표준에서는 다음의 공식을 사용한다.
  K = 2^(비트수 - 1) - 1
  ex. 8비트일 경우 ---> K = 2^7 - 1 = 127, 결과 = 127 + 값
      1111 1111 = 127 + 128
      1111 1110 = 127 + 127
      1111 1101 = 127 + 126
      1111 1100 = 127 + 125
               ...
      1000 0000 = 127 + 1
      0111 1111 = 127 + 0
      0111 1110 = 127 + (-1)
               ...
      0000 0010 = 127 + (-125)
      0000 0001 = 127 + (-126)
      0000 0000 = 127 + (-127)
      
- 장점
  => 모든 비트가 0일 때 최소 값, 모든 비트가 1일 때 최대 값
     이런 이유로 작은 값에서 큰 값으로 정렬
  => 모든 비트가 정렬된 상태이므로 부동소수점이든 정수이든 상관없이
     값을 비교할 때 속도가 빠름
  => '부호-크기', '1의 보수', '2의 보수'와 같은 방법으로 값을 표현할 경우,
     비트들이 순차적으로 정렬되지 않음
  => 부동 소수점의 지수(exponent)를 표현할 때 사용한
  ```